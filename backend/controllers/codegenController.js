const archiver = require('archiver');
const mongoose = require('mongoose');
const Brief = require('../models/Brief');

function safeSlug(s) {
  return String(s || 'stub')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
    .slice(0, 60) || 'stub';
}
function pascalCase(s) {
  return String(s || 'Component')
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map(w => w[0]?.toUpperCase() + w.slice(1).toLowerCase())
    .join('');
}

/* -------------------- FRONTEND (React) ZIP -------------------- */
async function zipFrontend({ title, description }, res) {
  const compName = pascalCase(title || 'GeneratedComponent');
  const base = safeSlug(title || 'frontend-stub');

  res.attachment(`${base}-frontend-stub.zip`);
  const archive = archiver('zip', { zlib: { level: 9 } });
  archive.pipe(res);

  const readme = `# ${compName}

Generated React component stub.

## Files
- \`src/components/${compName}.jsx\` — main component
- \`src/App.jsx\` — demo usage
- \`index.html\` — minimal page
- \`README.md\`

## Quick run (with Parcel or Vite)
- Parcel: \`parcel index.html\`
- Vite: move into a Vite app and import the component

`;
  const component = `import React, { useState } from 'react';

/**
 * ${compName}
 * ${description || 'Generated by Coordinator Frontend Agent'}
 */
export default function ${compName}({ onSubmit }) {
  const [name, setName] = useState('');
  const [desc, setDesc] = useState('');

  function submit(e) {
    e.preventDefault();
    onSubmit?.({ name, description: desc });
    setName('');
    setDesc('');
  }

  return (
    <div style={{ padding: 16, border: '1px solid #e5e7eb', borderRadius: 10 }}>
      <h2 style={{ marginTop: 0 }}>${compName}</h2>
      <p style={{ color: '#374151' }}>${description || ''}</p>
      <form onSubmit={submit} style={{ display: 'flex', gap: 8 }}>
        <input placeholder="Name" value={name} onChange={e => setName(e.target.value)} style={{ padding: 8, flex: 1 }} />
        <input placeholder="Description" value={desc} onChange={e => setDesc(e.target.value)} style={{ padding: 8, flex: 2 }} />
        <button type="submit" style={{ padding: '8px 12px' }}>Submit</button>
      </form>
    </div>
  );
}
`;
  const app = `import React from 'react';
import ReactDOM from 'react-dom/client';
import ${compName} from './components/${compName}.jsx';

function App() {
  return (
    <div style={{ fontFamily: 'system-ui, Arial', padding: 24 }}>
      <h1>Demo: ${compName}</h1>
      <${compName} onSubmit={data => alert(JSON.stringify(data, null, 2))} />
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
`;
  const html = `<!doctype html>
<html>
  <head><meta charset="utf-8" /><title>${compName} Demo</title></head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/App.jsx"></script>
  </body>
</html>
`;

  archive.append(readme, { name: 'README.md' });
  archive.append(component, { name: `src/components/${compName}.jsx` });
  archive.append(app, { name: 'src/App.jsx' });
  archive.append(html, { name: 'index.html' });
  await archive.finalize();
}

/* -------------------- BACKEND (Express+Mongoose) ZIP -------------------- */
async function zipBackend({ title, description }, res) {
  const entity = pascalCase(title || 'Generated');
  const slug = safeSlug(title || 'generated');
  const base = `${slug}-backend-stub`;

  res.attachment(`${base}.zip`);
  const archive = archiver('zip', { zlib: { level: 9 } });
  archive.pipe(res);

  const readme = `# ${entity} Backend Stub

Generated Express + Mongoose CRUD skeleton.

## Files
- \`models/${entity}.js\`
- \`controllers/${entity}Controller.js\`
- \`routes/${slug}Routes.js\`
- \`README.md\`

## Integration
- Mount routes: \`app.use('/api/${slug}', require('./routes/${slug}Routes'))\`
- Adjust schema, validation, and auth as needed.
`;

  const model = `const mongoose = require('mongoose');

const ${entity}Schema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true, required: true },
    name: { type: String, required: true, trim: true },
    description: { type: String, trim: true },
  },
  { timestamps: true }
);

module.exports = mongoose.model('${entity}', ${entity}Schema);
`;

  const controller = `const ${entity} = require('../models/${entity}');

exports.list = async (req, res) => {
  const items = await ${entity}.find({ userId: req.user.id }).sort({ createdAt: -1 });
  res.json(items);
};

exports.create = async (req, res) => {
  const { name, description } = req.body || {};
  if (!name) return res.status(400).json({ error: 'name required' });
  const doc = await ${entity}.create({ userId: req.user.id, name, description });
  res.status(201).json(doc);
};

exports.update = async (req, res) => {
  const { id } = req.params;
  const doc = await ${entity}.findOneAndUpdate({ _id: id, userId: req.user.id }, req.body, { new: true });
  if (!doc) return res.status(404).json({ error: 'not found' });
  res.json(doc);
};

exports.remove = async (req, res) => {
  const { id } = req.params;
  const doc = await ${entity}.findOneAndDelete({ _id: id, userId: req.user.id });
  if (!doc) return res.status(404).json({ error: 'not found' });
  res.json({ ok: true, id });
};
`;

  const routes = `const express = require('express');
const requireAuth = require('../middleware/requireAuth');
const ctrl = require('../controllers/${entity}Controller');

const router = express.Router();
router.use(requireAuth);

router.get('/', ctrl.list);
router.post('/', ctrl.create);
router.patch('/:id', ctrl.update);
router.delete('/:id', ctrl.remove);

module.exports = router;
`;

  archive.append(readme, { name: 'README.md' });
  archive.append(model, { name: `models/${entity}.js` });
  archive.append(controller, { name: `controllers/${entity}Controller.js` });
  archive.append(routes, { name: `routes/${slug}Routes.js` });
  await archive.finalize();
}

/* -------------------- Generate from a Brief plan item -------------------- */
async function generateFromPlan(req, res) {
  try {
    const { id, idx } = req.params;
    if (!mongoose.isValidObjectId(id)) return res.status(400).json({ error: 'invalid brief id' });
    const i = Number(idx);
    if (!Number.isInteger(i) || i < 0) return res.status(400).json({ error: 'invalid plan index' });

    const brief = await Brief.findOne({ _id: id, userId: req.user.id }).lean();
    if (!brief) return res.status(404).json({ error: 'brief not found' });
    const item = brief.plan?.[i];
    if (!item) return res.status(404).json({ error: 'plan item not found' });

    const payload = { title: item.title, description: item.description };

    if (item.area === 'frontend') {
      await zipFrontend(payload, res);
    } else {
      await zipBackend(payload, res);
    }
  } catch (e) {
    console.error('generateFromPlan error:', e);
    res.status(500).json({ error: e.message });
  }
}

/* -------------------- Direct endpoints (not via brief) -------------------- */
async function generateFrontend(req, res) {
  const { title, description } = req.body || {};
  await zipFrontend({ title, description }, res);
}
async function generateBackend(req, res) {
  const { title, description } = req.body || {};
  await zipBackend({ title, description }, res);
}

module.exports = {
  generateFromPlan,
  generateFrontend,
  generateBackend,
};
